<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/core/layer.js | Waves UI Piper API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/piper-audio/waves-ui-piper" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">axis</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/axis/axis-layer.js~AxisLayer.html">AxisLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-gridAxisGenerator">gridAxisGenerator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-timeAxisGenerator">timeAxisGenerator</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">behaviors</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/base-behavior.js~BaseBehavior.html">BaseBehavior</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/breakpoint-behavior.js~BreakpointBehavior.html">BreakpointBehavior</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/marker-behavior.js~MarkerBehavior.html">MarkerBehavior</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/segment-behavior.js~SegmentBehavior.html">SegmentBehavior</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/time-context-behavior.js~TimeContextBehavior.html">TimeContextBehavior</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/behaviors/trace-behavior.js~TraceBehavior.html">TraceBehavior</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/layer-time-context.js~LayerTimeContext.html">LayerTimeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/layer.js~Layer.html">Layer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/timeline-time-context.js~TimelineTimeContext.html">TimelineTimeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/timeline.js~Timeline.html">Timeline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/track-collection.js~TrackCollection.html">TrackCollection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/track.js~Track.html">Track</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">helpers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/annotated-marker-layer.js~AnnotatedMarkerLayer.html">AnnotatedMarkerLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/annotated-segment-layer.js~AnnotatedSegmentLayer.html">AnnotatedSegmentLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/breakpoint-layer.js~BreakpointLayer.html">BreakpointLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/cursor-layer.js~CursorLayer.html">CursorLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/grid-axis-layer.js~GridAxisLayer.html">GridAxisLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/highlight-layer.js~HighlightLayer.html">HighlightLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/line-layer.js~LineLayer.html">LineLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/marker-layer.js~MarkerLayer.html">MarkerLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/matrix-layer.js~MatrixLayer.html">MatrixLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/pianoroll-layer.js~PianoRollLayer.html">PianoRollLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/scale-layer.js~ScaleLayer.html">ScaleLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/segment-layer.js~SegmentLayer.html">SegmentLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/tick-layer.js~TickLayer.html">TickLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/time-axis-layer.js~TimeAxisLayer.html">TimeAxisLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/trace-layer.js~TraceLayer.html">TraceLayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/helpers/waveform-layer.js~WaveformLayer.html">WaveformLayer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">interactions</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interactions/event-source.js~EventSource.html">EventSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interactions/keyboard.js~Keyboard.html">Keyboard</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interactions/surface.js~Surface.html">Surface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interactions/wave-event.js~WaveEvent.html">WaveEvent</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">shapes</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/annotated-marker.js~AnnotatedMarker.html">AnnotatedMarker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/annotated-segment.js~AnnotatedSegment.html">AnnotatedSegment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/base-shape.js~BaseShape.html">BaseShape</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/crosshairs.js~Crosshairs.html">Crosshairs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/cursor.js~Cursor.html">Cursor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/dot.js~Dot.html">Dot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/line.js~Line.html">Line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/marker.js~Marker.html">Marker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/scale.js~Scale.html">Scale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/segment.js~Segment.html">Segment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/ticks.js~Ticks.html">Ticks</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/trace-dots.js~TraceDots.html">TraceDots</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/trace-path.js~TracePath.html">TracePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/shapes/waveform.js~Waveform.html">Waveform</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">states</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/base-state.js~BaseState.html">BaseState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/breakpoint-state.js~BreakpointState.html">BreakpointState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/brush-zoom-state.js~BrushZoomState.html">BrushZoomState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/centered-zoom-state.js~CenteredZoomState.html">CenteredZoomState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/context-edition-state.js~ContextEditionState.html">ContextEditionState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/edition-state.js~EditionState.html">EditionState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/selection-state.js~SelectionState.html">SelectionState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/states/simple-edition-state.js~SimpleEditionState.html">SimpleEditionState</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/matrix-entity.js~MatrixEntity.html">MatrixEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/orthogonal-data.js~OrthogonalData.html">OrthogonalData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/oversample.js~Oversampler.html">Oversampler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/png.js~PNGEncoder.html">PNGEncoder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/prefilled-matrix-entity.js~PrefilledMatrixEntity.html">PrefilledMatrixEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/scale-tick-intervals.js~ScaleTickIntervals.html">ScaleTickIntervals</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/layer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import events from &apos;events&apos;;
import ns from &apos;./namespace&apos;;
import scales from &apos;../utils/scales&apos;;
import Segment from &apos;../shapes/segment&apos;;
import TimeContextBehavior from &apos;../behaviors/time-context-behavior&apos;;

// time context bahevior
let timeContextBehavior = null;
let timeContextBehaviorCtor = TimeContextBehavior;

/**
 * The layer class is the main visualization class. It is mainly defines by its
 * related `LayerTimeContext` which determines its position in the overall
 * timeline (through the `start`, `duration`, `offset` and `stretchRatio`
 * attributes) and by it&apos;s registered Shape which defines how to display the
 * data associated to the layer. Each created layer must be inserted into a
 * `Track` instance in order to be displayed.
 *
 * _Note: in the context of the layer, an __item__ is the SVG element
 * returned by a `Shape` instance and associated with a particular __datum__._
 *
 * ### Layer DOM structure
 * ```
 * &lt;g class=&quot;layer&quot; transform=&quot;translate(${start}, 0)&quot;&gt;
 *   &lt;svg class=&quot;bounding-box&quot; width=&quot;${duration}&quot;&gt;
 *     &lt;g class=&quot;maingroup&quot;&gt;
 *       &lt;!-- background --&gt;
 *       &lt;rect class=&quot;background&quot;&gt;&lt;/rect&gt;
 *       &lt;!-- shapes and common shapes are inserted here --&gt;
 *     &lt;/g&gt;
 *     &lt;g class=&quot;interactions&quot;&gt;&lt;!-- for feedback --&gt;&lt;/g&gt;
 *   &lt;/svg&gt;
 * &lt;/g&gt;
 * ```
 */
export default class Layer extends events.EventEmitter {
  /**
   * @param {String} dataType - Defines how the layer should look at the data.
   *    Can be &apos;entity&apos; or &apos;collection&apos;.
   * @param {(Array|Object)} data - The data associated to the layer.
   * @param {Object} options - Configures the layer.
   * @param {Number} [options.height=100] - Defines the height of the layer.
   * @param {Number} [options.top=0] - Defines the top position of the layer.
   * @param {Number} [options.opacity=1] - Defines the opacity of the layer.
   * @param {Number} [options.yDomain=[0,1]] - Defines boundaries of the data
   *    values in y axis (for exemple to display an audio buffer, this attribute
   *    should be set to [-1, 1].
   * @param {String} [options.className=null] - An optionnal class to add to each
   *    created shape.
   * @param {String} [options.className=&apos;selected&apos;] - The class to add to a shape
   *    when selected.
   * @param {Number} [options.contextHandlerWidth=2] - The width of the handlers
   *    displayed to edit the layer.
   * @param {Number} [options.hittable=false] - Defines if the layer can be interacted
   *    with. Basically, the layer is not returned by `BaseState.getHitLayers` when
   *    set to false (a common use case is a layer that contains a cursor)
   */
  constructor(dataType, data, options = {}) {
    super();

    const defaults = {
      height: 100,
      top: 0,
      opacity: 1,
      yDomain: [0, 1],
      className: null,
      selectedClassName: &apos;selected&apos;,
      contextHandlerWidth: 2,
      hittable: true, // when false the layer is not returned by `BaseState.getHitLayers`
      id: &apos;&apos;, // used ?
      overflow: &apos;hidden&apos;, // usefull ?
    };

    /**
     * Parameters of the layers, `defaults` overrided with options.
     * @type {Object}
     */
    this.params = Object.assign({}, defaults, options);
    /**
     * Defines how the layer should look at the data (`&apos;entity&apos;` or `&apos;collection&apos;`).
     * @type {String}
     */
    this.dataType = dataType; // &apos;entity&apos; || &apos;collection&apos;;
    /** @type {LayerTimeContext} */
    this.timeContext = null;
    /** @type {Element} */
    this.$el = null;
    /** @type {Element} */
    this.$background = null;
    /** @type {Element} */
    this.$boundingBox = null;
    /** @type {Element} */
    this.$maingroup = null;
    /** @type {Element} */
    this.$interactions = null;
    /**
     * A Segment instanciated to interact with the Layer itself.
     * @type {Segment}
     */
    this.contextShape = null;

    this._shapeConfiguration = null;       // { ctor, accessors, options }
    this._commonShapeConfiguration = null; // { ctor, accessors, options }
    this._$itemShapeMap = new Map();
    this._$itemDataMap = new Map();
    this._$itemCommonShapeMap = new Map();

    this._isContextEditable = false;
    this._behavior = null;

    this.data = data;

    this._valueToPixel = scales.linear()
      .domain(this.params.yDomain)
      .range([0, this.params.height]);

    // initialize timeContext layout
    this._renderContainer();
    // creates the timeContextBehavior for all layers
    if (timeContextBehavior === null) {
      timeContextBehavior = new timeContextBehaviorCtor();
    }
  }

  /**
   * Destroy the layer, clear all references.
   */
  destroy() {

    if (this.dataType == &apos;entity&apos;) {
      if (typeof(this.data.dispose) !== &apos;undefined&apos;) {
        this.data.dispose();
      }
    }
    
    this.timeContext = null;
    this.data = null;
    this.params = null;
    this._behavior = null;

    this._$itemShapeMap.clear();
    this._$itemDataMap.clear();
    this._$itemCommonShapeMap.clear();

    this.removeAllListeners();
  }

  /**
   * Allows to override default the `TimeContextBehavior` used to edit the layer.
   *
   * @param {Object} ctor
   */
  static configureTimeContextBehavior(ctor) {
    timeContextBehaviorCtor = ctor;
  }

  /**
   * Returns `LayerTimeContext`&apos;s `start` time domain value.
   *
   * @type {Number}
   */
  get start() {
    return this.timeContext.start;
  }

  /**
   * Sets `LayerTimeContext`&apos;s `start` time domain value.
   *
   * @type {Number}
   */
  set start(value) {
    this.timeContext.start = value;
  }

  /**
   * Returns `LayerTimeContext`&apos;s `offset` time domain value.
   *
   * @type {Number}
   */
  get offset() {
    return this.timeContext.offset;
  }

  /**
   * Sets `LayerTimeContext`&apos;s `offset` time domain value.
   *
   * @type {Number}
   */
  set offset(value) {
    this.timeContext.offset = value;
  }

  /**
   * Returns `LayerTimeContext`&apos;s `duration` time domain value.
   *
   * @type {Number}
   */
  get duration() {
    return this.timeContext.duration;
  }

  /**
   * Sets `LayerTimeContext`&apos;s `duration` time domain value.
   *
   * @type {Number}
   */
  set duration(value) {
    this.timeContext.duration = value;
  }

  /**
   * Returns `LayerTimeContext`&apos;s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
  get stretchRatio() {
    return this.timeContext.stretchRatio;
  }

  /**
   * Sets `LayerTimeContext`&apos;s `stretchRatio` time domain value.
   *
   * @type {Number}
   */
  set stretchRatio(value) {
    this.timeContext.stretchRatio = value;
  }

  /**
   * Set the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
  set yDomain(domain) {
    this.params.yDomain = domain;
    this._valueToPixel.domain(domain);
  }

  /**
   * Returns the domain boundaries of the data for the y axis.
   *
   * @type {Array}
   */
  get yDomain() {
    return this.params.yDomain;
  }

  /**
   * Sets the opacity of the whole layer.
   *
   * @type {Number}
   */
  set opacity(value) {
    this.params.opacity = value;
  }

  /**
   * Returns the opacity of the whole layer.
   *
   * @type {Number}
   */
  get opacity() {
    return this.params.opacity;
  }

  /**
   * Returns the transfert function used to display the data in the x axis.
   *
   * @type {Number}
   */
  get timeToPixel() {
    return this.timeContext.timeToPixel;
  }

  /**
   * Returns the transfert function used to display the data in the y axis.
   *
   * @type {Number}
   */
  get valueToPixel() {
    return this._valueToPixel;
  }

  /**
   * Returns an array containing all the displayed items.
   *
   * @type {Array&lt;Element&gt;}
   */
  get items() {
    return Array.from(this._$itemDataMap.keys());
  }

  /**
   * Returns the data associated to the layer.
   *
   * @type {Object[]}
   */
  get data() { return this._data; }

  /**
   * Sets the data associated with the layer.
   *
   * @type {Object|Object[]}
   */
  set data(data) {
    switch (this.dataType) {
    case &apos;entity&apos;:
      if (this._data) {  // if data already exists, reuse the reference
        this._data[0] = data;
      } else {
        this._data = [data];
      }
      break;
    case &apos;collection&apos;:
      this._data = data;
      break;
    }
    this._cached = false;
  }

  // --------------------------------------
  // Initialization
  // --------------------------------------

  /**
   * Renders the DOM in memory on layer creation to be able to use it before
   * the layer is actually inserted in the DOM.
   */
  _renderContainer() {
    // wrapper group for `start, top and context flip matrix
    this.$el = document.createElementNS(ns, &apos;g&apos;);
    this.$el.classList.add(&apos;layer&apos;);
    if (this.params.className !== null) {
      this.$el.classList.add(this.params.className);
    }
    // clip the context with a `svg` element
    this.$boundingBox = document.createElementNS(ns, &apos;svg&apos;);
    this.$boundingBox.classList.add(&apos;bounding-box&apos;);
    this.$boundingBox.style.overflow = this.params.overflow;
    // group to contain layer items
    this.$maingroup = document.createElementNS(ns, &apos;g&apos;);
    this.$maingroup.classList.add(&apos;maingroup&apos;, &apos;items&apos;);
    // layer background
    this.$background = document.createElementNS(ns, &apos;rect&apos;);
    this.$background.setAttributeNS(null, &apos;height&apos;, &apos;100%&apos;);
    this.$background.setAttributeNS(null, &apos;width&apos;, &apos;100%&apos;);
    this.$background.classList.add(&apos;background&apos;);
    this.$background.style.fillOpacity = 0;
    this.$background.style.pointerEvents = &apos;none&apos;;
    // context interactions
    this.$interactions = document.createElementNS(ns, &apos;g&apos;);
    this.$interactions.classList.add(&apos;interactions&apos;);
    this.$interactions.style.display = &apos;none&apos;;
    // @NOTE: works but king of ugly... should be cleaned
    this.contextShape = new Segment();
    this.contextShape.install({
      opacity: () =&gt; 0.1,
      color  : () =&gt; &apos;#787878&apos;,
      width  : () =&gt; this.timeContext.duration,
      height : () =&gt; this._renderingContext.valueToPixel.domain()[1],
      y      : () =&gt; this._renderingContext.valueToPixel.domain()[0]
    });

    this.$interactions.appendChild(this.contextShape.render());
    // create the DOM tree
    this.$el.appendChild(this.$boundingBox);
    this.$boundingBox.appendChild(this.$maingroup);
    this.$maingroup.appendChild(this.$background);
    this.$boundingBox.appendChild(this.$interactions);
  }

  // --------------------------------------
  // Component Configuration
  // --------------------------------------

  /**
   * Sets the context of the layer, thus defining its `start`, `duration`,
   * `offset` and `stretchRatio`.
   *
   * @param {TimeContext} timeContext - The timeContext in which the layer is displayed.
   */
  setTimeContext(timeContext) {
    this.timeContext = timeContext;
    // create a mixin to pass to the shapes
    this._renderingContext = {};
    this._updateRenderingContext();
  }

  /**
   * Register a shape and its configuration to use in order to render the data.
   *
   * @param {BaseShape} ctor - The constructor of the shape to be used.
   * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
   * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
   */
  configureShape(ctor, accessors = {}, options = {}) {
    this._shapeConfiguration = { ctor, accessors, options };
  }

  /**
   * Optionally register a shape to be used across the entire collection.
   *
   * @param {BaseShape} ctor - The constructor of the shape to be used.
   * @param {Object} [accessors={}] - Defines how the shape should adapt to a particular data struture.
   * @param {Object} [options={}] - Global configuration for the shapes, is specific to each `Shape`.
   */
  configureCommonShape(ctor, accessors = {}, options = {}) {
    this._commonShapeConfiguration = { ctor, accessors, options };
  }

  /**
   * Register the behavior to use when interacting with a shape.
   *
   * @param {BaseBehavior} behavior
   */
  setBehavior(behavior) {
    behavior.initialize(this);
    this._behavior = behavior;
  }

  /**
   * Updates the values stored in the `_renderingContext` passed  to shapes
   * for rendering and updating.
   */
  _updateRenderingContext() {

    // PLAN
    //
    // The time context structures stay the same. They continue to map
    // time in seconds onto an absolute pixel axis that starts at
    // pixel 0 == time 0 and pixel N == time (N / pixels-per-second).
    //
    // The rendering context, on the other hand, has pixel 0 at the
    // left edge of the visible area, so that the rendered SVG has
    // width (in its coordinate scheme) equal to the visible area. We
    // always resituate ourselves there so as to avoid extremely large
    // SVG coordinates when both zoomed in a long way and scrolled a
    // long way to the right, as browser renderers generally seem to
    // blow up when presented with coords above 2^24 or so.
    // 
    // To arrange pixel 0 at the left edge, we need to ensure that the
    // time-to-pixel mapping places time 0 at pixel -minX where minX
    // is the time context&apos;s timeToPixel mapping of the sum of all
    // applicable time offsets.
    
    const layerStartTime = this.timeContext.start;
    const layerOffsetTime = this.timeContext.offset;
    const trackOffsetTime = this.timeContext.parent.offset;

    const layerOriginTime = trackOffsetTime + layerStartTime;

    const viewStartTime = -layerOriginTime - layerOffsetTime;
    
    this._renderingContext.timeToPixel = scales.linear()
      .domain([viewStartTime, viewStartTime + 1])
      .range([0, this.timeContext.timeToPixel(1)]);
    
    this._renderingContext.minX = 0;

    this._renderingContext.visibleWidth = this.timeContext.parent.visibleWidth;
    this._renderingContext.width = this._renderingContext.visibleWidth;
    this._renderingContext.maxX = this._renderingContext.visibleWidth;
    
    this._renderingContext.height = this.params.height;
    this._renderingContext.valueToPixel = this._valueToPixel;

    console.log(&quot;Rendering context: width = &quot; + this._renderingContext.width + &quot;, visibleWidth = &quot; + this._renderingContext.visibleWidth + &quot;, minX = &quot; + this._renderingContext.minX + &quot; (time = &quot; + this._renderingContext.timeToPixel.invert(this._renderingContext.minX) + &quot;), maxX = &quot; + this._renderingContext.maxX + &quot; (time = &quot; + this._renderingContext.timeToPixel.invert(this._renderingContext.maxX) + &quot;)&quot;);
  }

  // --------------------------------------
  // Behavior Accessors
  // --------------------------------------

  /**
   * Returns the items marked as selected.
   *
   * @type {Array&lt;Element&gt;}
   */
  get selectedItems() {
    return this._behavior ? this._behavior.selectedItems : [];
  }

  /**
   * Mark item(s) as selected.
   *
   * @param {Element|Element[]} $items
   */
  select(...$items) {
    if (!this._behavior) { return; }
    if (!$items.length) { $items = this._$itemDataMap.keys(); }
    if (Array.isArray($items[0])) { $items = $items[0]; }

    for (let $item of $items) {
      const datum = this._$itemDataMap.get($item);
      this._behavior.select($item, datum);
      this._toFront($item);
    }
  }

  /**
   * Removes item(s) from selected items.
   *
   * @param {Element|Element[]} $items
   */
  unselect(...$items) {
    if (!this._behavior) { return; }
    if (!$items.length) { $items = this._$itemDataMap.keys(); }
    if (Array.isArray($items[0])) { $items = $items[0]; }

    for (let $item of $items) {
      const datum = this._$itemDataMap.get($item);
      this._behavior.unselect($item, datum);
    }
  }

  /**
   * Toggle item(s) selection state according to their current state.
   *
   * @param {Element|Element[]} $items
   */
  toggleSelection(...$items) {
    if (!this._behavior) { return; }
    if (!$items.length) { $items = this._$itemDataMap.keys(); }
    if (Array.isArray($items[0])) { $items = $items[0]; }

    for (let $item of $items) {
      const datum = this._$itemDataMap.get($item);
      this._behavior.toggleSelection($item, datum);
    }
  }

  /**
   * Edit item(s) according to the `edit` defined in the registered `Behavior`.
   *
   * @param {Element|Element[]} $items - The item(s) to edit.
   * @param {Number} dx - The modification to apply in the x axis (in pixels).
   * @param {Number} dy - The modification to apply in the y axis (in pixels).
   * @param {Element} $target - The target of the interaction (for example, left
   *    handler DOM element in a segment).
   */
  edit($items, dx, dy, $target) {
    if (!this._behavior) { return; }
    $items = !Array.isArray($items) ? [$items] : $items;

    for (let $item of $items) {
      const shape = this._$itemShapeMap.get($item);
      const datum = this._$itemDataMap.get($item);

      this._behavior.edit(this._renderingContext, shape, datum, dx, dy, $target);
      this.emit(&apos;edit&apos;, shape, datum);
    }
  }

  /**
   * Defines if the `Layer`, and thus the `LayerTimeContext` is editable or not.
   *
   * @params {Boolean} [bool=true]
   */
  setContextEditable(bool = true) {
    const display = bool ? &apos;block&apos; : &apos;none&apos;;
    this.$interactions.style.display = display;
    this._isContextEditable = bool;
  }

  /**
   * Edit the layer and thus its related `LayerTimeContext` attributes.
   *
   * @param {Number} dx - The modification to apply in the x axis (in pixels).
   * @param {Number} dy - The modification to apply in the y axis (in pixels).
   * @param {Element} $target - The target of the event of the interaction.
   */
  editContext(dx, dy, $target) {
    timeContextBehavior.edit(this, dx, dy, $target);
  }

  /**
   * Stretch the layer and thus its related `LayerTimeContext` attributes.
   *
   * @param {Number} dx - The modification to apply in the x axis (in pixels).
   * @param {Number} dy - The modification to apply in the y axis (in pixels).
   * @param {Element} $target - The target of the event of the interaction.
   */
  stretchContext(dx, dy, $target) {
    timeContextBehavior.stretch(this, dx, dy, $target);
  }

  // --------------------------------------
  // Helpers
  // --------------------------------------

  /**
   * Returns an item from a DOM element related to the shape, null otherwise.
   *
   * @param {Element} $el - the element to be tested
   * @return {Element|null}
   */
  getItemFromDOMElement($el) {
    let $item;

    do {
      if ($el.classList &amp;&amp; $el.classList.contains(&apos;item&apos;)) {
        $item = $el;
        break;
      }

      $el = $el.parentNode;
    } while ($el !== null);

    return this.hasItem($item) ? $item :&#xA0;null;
  }

  /**
   * Returns the datum associated to a specific item.
   *
   * @param {Element} $item
   * @return {Object|Array|null}
   */
  getDatumFromItem($item) {
    const datum = this._$itemDataMap.get($item);
    return datum ? datum : null;
  }

  /**
   * Returns the datum associated to a specific item from any DOM element
   * composing the shape. Basically a shortcut for `getItemFromDOMElement` and
   * `getDatumFromItem` methods.
   *
   * @param {Element} $el
   * @return {Object|Array|null}
   */
  getDatumFromDOMElement($el) {
    var $item = this.getItemFromDOMElement($el);
    if ($item === null) { return null; }
    return this.getDatumFromItem($item);
  }

  /**
   * Tests if the given DOM element is an item of the layer.
   *
   * @param {Element} $item - The item to be tested.
   * @return {Boolean}
   */
  hasItem($item) {
    return this._$itemDataMap.has($item);
  }

  /**
   * Defines if a given element belongs to the layer. Is more general than
   * `hasItem`, can mostly used to check interactions elements.
   *
   * @param {Element} $el - The DOM element to be tested.
   * @return {bool}
   */
  hasElement($el) {
    do {
      if ($el === this.$el) {
        return true;
      }

      $el = $el.parentNode;
    } while ($el !== null);

    return false;
  }

  /**
   * Retrieve all the items in a given area as defined in the registered `Shape~inArea` method.
   *
   * @param {Object} area - The area (in viewport coordinate space) in which to find the elements
   * @param {Number} area.top
   * @param {Number} area.left
   * @param {Number} area.width
   * @param {Number} area.height
   * @return {Array} - list of the items presents in the area
   */
  getItemsInArea(area) {

    let x1 = area.left;
    let x2 = area.left + area.width;

    // keep consistent with context y coordinates system
    let y1 = this.params.height - (area.top + area.height);
    let y2 = this.params.height - area.top;

    y1 += this.params.top;
    y2 += this.params.top;

    const $filteredItems = [];

    for (let [$item, datum] of this._$itemDataMap.entries()) {
      const shape = this._$itemShapeMap.get($item);
      const inArea = shape.inArea(this._renderingContext, datum, x1, y1, x2, y2);

      if (inArea) { $filteredItems.push($item); }
    }

    return $filteredItems;
  }

  // --------------------------------------
  // Rendering / Display methods
  // --------------------------------------

  /**
   * Moves an item to the end of the layer to display it front of its
   * siblings (svg z-index...).
   *
   * @param {Element} $item - The item to be moved.
   */
  _toFront($item) {
    this.$maingroup.appendChild($item);
  }

  /**
   * Create the DOM structure of the shapes according to the given data. Inspired
   * from the `enter` and `exit` d3.js paradigm, this method should be called
   * each time a datum is added or removed from the data. While the DOM is
   * created the `update` method must be called in order to update the shapes
   * attributes and thus place them where they should.
   */
  render() {

    const before = performance.now();
    
    // render `commonShape` only once
    if (
      this._commonShapeConfiguration !== null &amp;&amp;
      this._$itemCommonShapeMap.size === 0
    ) {
      const { ctor, accessors, options } = this._commonShapeConfiguration;
      const $group = document.createElementNS(ns, &apos;g&apos;);
      const shape = new ctor(options);

      shape.install(accessors);
      $group.appendChild(shape.render());
      $group.classList.add(&apos;item&apos;, &apos;common&apos;, shape.getClassName());

      this._$itemCommonShapeMap.set($group, shape);
      this.$maingroup.appendChild($group);
    }

    // append elements all at once
    const fragment = document.createDocumentFragment();
    const values = this._$itemDataMap.values(); // iterator

    // enter
    if (this._shapeConfiguration !== null) {
      this.data.forEach((datum) =&gt; {
        for (let value of values) { if (value === datum) { return; } }

        const { ctor, accessors, options } = this._shapeConfiguration;
        const shape = new ctor(options);
        shape.install(accessors);

        const $el = shape.render(this._renderingContext);
        $el.classList.add(&apos;item&apos;, shape.getClassName());

        this._$itemShapeMap.set($el, shape);
        this._$itemDataMap.set($el, datum);

        fragment.appendChild($el);
      });

      this.$maingroup.appendChild(fragment);
    }

    // remove
    for (let [$item, datum] of this._$itemDataMap.entries()) {
      if (this.data.indexOf(datum) !== -1) { continue; }

      const shape = this._$itemShapeMap.get($item);

      this.$maingroup.removeChild($item);
      shape.destroy();
      // a removed item cannot be selected
      if (this._behavior) {
        this._behavior.unselect($item, datum);
      }

      this._$itemDataMap.delete($item);
      this._$itemShapeMap.delete($item);
    }

    const after = performance.now();
    console.log(&quot;layer render time = &quot; + Math.round(after - before));
  }

  /**
   * Updates the container of the layer and the attributes of the existing shapes.
   */
  update() {
    console.log(&quot;layer update called&quot;);
    
    this._updateContainer();
    this._updateShapes();
  }

  /**
   * Updates the container of the layer.
   */
  _updateContainer() {
    this._updateRenderingContext();

    const timeContext = this.timeContext;

    let width = this._renderingContext.timeToPixel(this.timeContext.duration);
    if (width &gt; this._renderingContext.visibleWidth) {
      width = this._renderingContext.visibleWidth;
    }
    
    const top = this.params.top;
    const height = this.params.height;
    
    // matrix to invert the coordinate system
    const translateMatrix = `matrix(1, 0, 0, -1, 0, ${top + height})`;

    this.$el.setAttributeNS(null, &apos;transform&apos;, translateMatrix);

    this.$boundingBox.setAttributeNS(null, &apos;width&apos;, width);
    this.$boundingBox.setAttributeNS(null, &apos;height&apos;, height);
    this.$boundingBox.style.opacity = this.params.opacity;

    // maintain context shape
    this.contextShape.update(this._renderingContext, this.timeContext, 0);
  }

  _encacheEntity() {

    if (this.dataType !== &apos;entity&apos;) return;
    if (this._cached) return;
    if (this._data === []) return;
    
    let origData = this._data[0];

    for (let [$item, datum] of this._$itemDataMap.entries()) {
      if (datum === origData) {
        const shape = this._$itemShapeMap.get($item);
        const cache = shape.encache(datum);
	if (cache) {
	  console.log(&quot;replacing our entity data with cached value&quot;);
	  this._$itemDataMap.set($item, cache);
          if (typeof(origData.dispose) !== &apos;undefined&apos;) {
            console.log(&quot;and calling dispose on entity data&quot;);
            origData.dispose();
          }
	  this.data = cache;
	}
      }
    }

    this._cached = true;
  }
  
  /**
   * Updates the attributes of all the `Shape` instances rendered into the layer.
   */
  _updateShapes() {

    console.log(&quot;layer updateShapes called&quot;);
    
    const before = performance.now();
    
    this._updateRenderingContext();

    this._encacheEntity();
    
    // Update common shape, if any
    this._$itemCommonShapeMap.forEach((shape, $item) =&gt; {
      shape.update(this._renderingContext, this.data);
    });

    console.log(&quot;item data map contains &quot; + this._$itemDataMap.size + &quot; entries&quot;);
    
    // Update specific shapes
    for (let [$item, datum] of this._$itemDataMap.entries()) {
      const shape = this._$itemShapeMap.get($item);
      shape.update(this._renderingContext, datum);
    }

    const after = performance.now();
    console.log(&quot;layer update time = &quot; + Math.round(after - before));
  }

  describe(x) {
    for (let [$item, datum] of this._$itemDataMap.entries()) {
      const shape = this._$itemShapeMap.get($item);
      const description = shape.describe(datum, x);
      if (description !== null) {
        return description;
      }
    }
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
